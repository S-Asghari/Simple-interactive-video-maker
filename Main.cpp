#include <opencv2/core/core.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/video/background_segm.hpp>
#include <opencv2/video/video.hpp>
#include <iostream>
#include <sstream>
#include <vector>
#include <stdlib.h>
#include <time.h> 
#include <utility>

using namespace cv;
using namespace std;

Mat frame; //current frame
Mat Drop;

Mat edges;
//Mat blurred_img;
Mat gray;
Mat color;
Mat cartoon;

Mat fgMaskMOG; //fg mask generated by MOG method
Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
Ptr<BackgroundSubtractor> pMOG; //MOG Background subtractor
Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor
int keyboard;

vector < pair <int, int> > drops;

void processVideo(char* videoFilename);
void processCamera();

struct RGB 
{
    uchar blue;
    uchar green;
    uchar red;  
};

int main(int argc, char* argv[])
{
    if(argc != 3) {
        cerr <<"Incorrect input list" << endl;
        cerr <<"exiting..." << endl;
        return EXIT_FAILURE;
    }

	Drop = imread("C:/Users/Sara/Desktop/image_proccessing/drop3.png", CV_LOAD_IMAGE_COLOR);
	//cout << Drop.cols << " " << Drop.rows << endl;
	resize(Drop, Drop, cv::Size(Drop.cols / 7.2, Drop.rows / 7.2), 0, 0, CV_INTER_LINEAR);	//drop3 : 7.2	//flower : 27.5
	//cout << Drop.cols << " " << Drop.rows << endl;

	//namedWindow("Drop", WINDOW_AUTOSIZE);
	//imshow("Drop", Drop);

    //create GUI windows
    namedWindow("Frame");
	namedWindow("FG");
    namedWindow("FG Mask MOG");
    namedWindow("FG Mask MOG 2");
	//namedWindow("edges");
	//namedWindow("color");
	//namedWindow("cartoon");

    //create Background Subtractor objects
    pMOG= new BackgroundSubtractorMOG(); //MOG approach
    pMOG2 = new BackgroundSubtractorMOG2(); //MOG2 approach

    if(strcmp(argv[1], "-vid") == 0)	//"strcmp()" returns 0 only if the contents of both strings are equal
	{       
        processVideo(argv[2]);
    }
	else if(strcmp(argv[1], "-cam") == 0)
	{
		processCamera();
	}
    else 
	{
        cerr <<"Please, check the input parameters." << endl;
        cerr <<"Exiting..." << endl;
        return EXIT_FAILURE;
    }

    //destroy GUI windows
    destroyAllWindows();
    return EXIT_SUCCESS;
}


void processVideo(char* videoFilename) 
{
	VideoCapture capture;
	capture.open(videoFilename);
    if(!capture.isOpened())
	{
        cerr << "Unable to open video file: " << videoFilename << endl;
        exit(EXIT_FAILURE);
    }

	capture >> frame;
	resize(frame, frame, Size(frame.cols * 0.75, frame.rows * 0.75), 0, 0, CV_INTER_LINEAR);
	
	VideoWriter video("C:/Users/Sara/Desktop/image_proccessing/output.avi", CV_FOURCC('M','J','P','G'), 10, Size(frame.cols,frame.rows));

	srand(time(0));
	for (int i = 0; i < 300; i++)
	{
		drops.push_back(pair<int, int>(rand()%frame.cols , rand()%frame.rows));
		if (drops.back().first <= 11)
		{
			drops.back().first += 11;
		}
		else if(frame.cols - drops.back().first <= 11)
		{
			drops.back().first -= 11;
		}
		if (drops.back().second <= 16)
		{
			drops.back().second += 16;
		}
		else if(frame.rows - drops.back().second <= 16)
		{
			drops.back().second -= 16;
		}
	}

	while ((char)keyboard != 'q' && (char)keyboard != 27)
	{
		//capture >> frame;
		if (!capture.read(frame))
		{
			cerr << "Unable to read next frame." << endl;
            cerr << "Exiting..." << endl;
			exit(EXIT_FAILURE);
			//break; 
		}
		resize(frame, frame, Size(frame.cols * 0.75, frame.rows * 0.75), 0, 0, CV_INTER_LINEAR);

		if (drops.size() < 300)
		{
			int size = drops.size();
			for (int i = 0; i < 300 - size; i++)
			{
				drops.push_back(pair<int, int>(rand()%frame.cols , rand()%frame.rows));
				if (drops.back().first <= 11)
				{
					drops.back().first += 11;
				}
				else if(frame.cols - drops.back().first <= 11)
				{
					drops.back().first -= 11;
				}
				if (drops.back().second <= 16)
				{
					drops.back().second += 16;
				}
				else if(frame.rows - drops.back().second <= 16)
				{
					drops.back().second -= 16;
				}
			}
		}

		cvtColor(frame, gray, COLOR_BGR2GRAY, 0);
		medianBlur(gray, gray, 5);

		//adaptiveThreshold(gray, edges, 255, ADAPTIVE_THRESH_MEAN_C, THRESH_BINARY, 9, 4);
		//medianBlur(frame, blurred_img, 5);
		//Canny(blurred_img, edges, 75, 150, 3, 0);
		//bilateralFilter(frame, color, 9, 300, 300, 4);
		//bitwise_and(color, color, cartoon, edges);

		pMOG->operator()(gray, fgMaskMOG);
		pMOG2->operator()(gray, fgMaskMOG2);

		Mat fg;
		frame.copyTo(fg, fgMaskMOG2);

		for (int i = 0; i < drops.size(); i++)
		{
			bool white = 0;
			int height;
			for (int k = 16; k < drops[i].second; k++)
			{
				RGB rgb = fg.ptr<RGB>(k)[drops[i].first];
				if ((int)rgb.blue != 0  || (int)rgb.green != 0 || (int)rgb.red  != 0)
				{
					height = k;
					white = 1;
					break;
				}
			}
			if (white == 0)
			{
				drops[i].second += 20;
				if (drops[i].second > frame.rows-16)
				{
					drops.erase(drops.begin()+i, drops.begin()+i+1 );	
				}
				else
				{
					//circle(frame, Point(drops[i].first, drops[i].second), 4, Scalar(255, 191, 0), -1, 8, 0);
					Drop.copyTo(frame(cv::Rect(drops[i].first, drops[i].second, Drop.cols, Drop.rows)));
				}
			}
			else
			{
				//circle(frame, Point(drops[i].first, height), 4, Scalar(255, 191, 0), -1, 8, 0);
				Drop.copyTo(frame(cv::Rect(drops[i].first, height, Drop.cols, Drop.rows)));
			}
		}
		
		rectangle(frame, cv::Point(10, 2), cv::Point(100,20), cv::Scalar(255,255,255), -1);

		stringstream ss;
		ss << capture.get(CV_CAP_PROP_POS_FRAMES);
        string frameNumberString = ss.str();
		putText(frame, frameNumberString.c_str(), cv::Point(15, 15), FONT_HERSHEY_SIMPLEX, 0.5 , cv::Scalar(0,0,0));

		video.write(frame);

		imshow("Frame", frame);
		imshow("FG", fg);
        //imshow("FG Mask MOG", fgMaskMOG);
        imshow("FG Mask MOG 2", fgMaskMOG2);
		//imshow("edges", edges);
		//imshow("color", color);
		//imshow("cartoon", cartoon);

		keyboard = waitKey( 30 );
	}
    capture.release();
	video.release();
}


void processCamera() 
{
	VideoCapture capture;
	capture.open(0);
    if(!capture.isOpened())
	{
        cerr << "Unable to open camera" << endl;
        exit(EXIT_FAILURE);
    }

	capture >> frame;

	srand(time(0));
	for (int i = 0; i < 300; i++)
	{
		drops.push_back(pair<int, int>(rand()%frame.cols , rand()%frame.rows));
		if (drops.back().first <= 11)
		{
			drops.back().first += 11;
		}
		else if(frame.cols - drops.back().first <= 11)
		{
			drops.back().first -= 11;
		}
		if (drops.back().second <= 16)
		{
			drops.back().second += 16;
		}
		else if(frame.rows - drops.back().second <= 16)
		{
			drops.back().second -= 16;
		}
	}

	while ((char)keyboard != 'q' && (char)keyboard != 27)
	{
		capture >> frame;

		if (drops.size() < 300)
		{
			int size = drops.size();
			for (int i = 0; i < 300 - size; i++)
			{
				drops.push_back(pair<int, int>(rand()%frame.cols , rand()%frame.rows));
				if (drops.back().first <= 11)
				{
					drops.back().first += 11;
				}
				else if(frame.cols - drops.back().first <= 11)
				{
					drops.back().first -= 11;
				}
				if (drops.back().second <= 16)
				{
					drops.back().second += 16;
				}
				else if(frame.rows - drops.back().second <= 16)
				{
					drops.back().second -= 16;
				}
			}
		}

		cvtColor(frame, gray, COLOR_BGR2GRAY, 0);
		medianBlur(gray, gray, 5);

		//adaptiveThreshold(gray, edges, 255, ADAPTIVE_THRESH_MEAN_C, THRESH_BINARY, 9, 4);
		//medianBlur(frame, blurred_img, 5);
		//Canny(blurred_img, edges, 75, 150, 3, 0);
		//bilateralFilter(frame, color, 9, 300, 300, 4);
		//bitwise_and(color, color, cartoon, edges);

		pMOG->operator()(gray, fgMaskMOG);
		pMOG2->operator()(gray, fgMaskMOG2);

		Mat fg;
		frame.copyTo(fg, fgMaskMOG);

		for (int i = 0; i < drops.size(); i++)
		{
			bool white = 0;
			int height;
			for (int k = 16; k < drops[i].second; k++)
			{
				RGB rgb = fg.ptr<RGB>(k)[drops[i].first];
				if ((int)rgb.blue != 0 || (int)rgb.green != 0 || (int)rgb.red != 0)
				{
					height = k;
					white = 1;
					break;
				}
			}
			if (white == 0)
			{
				drops[i].second += 20;
				if (drops[i].second > frame.rows - 16)
				{
					drops.erase(drops.begin()+i, drops.begin()+i+1 );	
				}
				else
				{
					//circle(frame, Point(drops[i].first, drops[i].second), 4, Scalar(255, 191, 0), -1, 8, 0);
					Drop.copyTo(frame(cv::Rect(drops[i].first, drops[i].second, Drop.cols, Drop.rows)));
				}
			}
			else
			{
				//circle(frame, Point(drops[i].first, height), 4, Scalar(255, 191, 0), -1, 8, 0);
				Drop.copyTo(frame(cv::Rect(drops[i].first, height, Drop.cols, Drop.rows)));
			}
		}

		imshow("Frame", frame);
		imshow("FG", fg);
        imshow("FG Mask MOG", fgMaskMOG);
        imshow("FG Mask MOG 2", fgMaskMOG2);
		//imshow("edges", edges);
		//imshow("color", color);
		//imshow("cartoon", cartoon);

		keyboard = waitKey( 30 );

	}
    capture.release();
}
